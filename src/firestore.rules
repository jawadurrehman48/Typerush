rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //----------------------------------------------------------------//
    //                        Helper Functions                        //
    //----------------------------------------------------------------//

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(ownerId) {
      return isOwner(ownerId) && resource != null;
    }

    function isRaceHost(raceId) {
      let race = get(/databases/$(database)/documents/races/$(raceId));
      return isSignedIn() && race.data.host == request.auth.token.name;
    }

    function isCreatingValidUserProfile(userId) {
      let data = request.resource.data;
      return isOwner(userId)
             && data.id == userId
             && data.email == request.auth.token.email
             && data.username == request.resource.data.username
             && data.highestWPM == 0
             && data.gamesPlayed == 0;
    }

    function isUpdatingValidUserProfile() {
        let incomingData = request.resource.data;
        let existingData = resource.data;
        let isIdUnchanged = incomingData.id == existingData.id;
        let allowedFieldsUpdated = incomingData.diff(existingData).affectedKeys().hasOnly(['gamesPlayed', 'highestWPM', 'username', 'photoURL']);

        return isIdUnchanged && allowedFieldsUpdated;
    }

    function isCreatingValidGameEntry() {
        let data = request.resource.data;
        return data.score is number && data.score >= 0
            && data.accuracy is number && data.accuracy >= 0 && data.accuracy <= 100
            && data.timestamp == request.time;
    }

    function isCreatingValidLeaderboardEntry() {
      let data = request.resource.data;
      return data.userId == request.auth.uid
          && data.username == request.auth.token.name
          && data.score is number && data.score > 0
          && data.accuracy is number && data.accuracy >= 0 && data.accuracy <= 100
          && data.timestamp == request.time;
    }

    function isUpdatingValidLeaderboardEntry() {
      let data = request.resource.data;
      return data.userId == resource.data.userId
          && data.username == resource.data.username
          && data.timestamp == resource.data.timestamp;
    }

    function isCreatingValidRace(raceId) {
        let raceData = request.resource.data;
        let auth = request.auth;
        
        let isValidRace = raceData.host == auth.token.name
            && raceData.status == 'waiting'
            && raceData.playerCount == 1;

        return isValidRace;
    }

    function isUpdatingValidRace(raceId) {
      let incomingData = request.resource.data;
      let existingData = resource.data;

      // Rule for a new player joining a race
      let isJoining = isSignedIn()
                      && incomingData.diff(existingData).affectedKeys().hasOnly(['playerCount'])
                      && incomingData.playerCount == existingData.playerCount + 1
                      && existingData.status == 'waiting';

      // Rule for the host starting the race
      let isHostStartingRace = isRaceHost(raceId)
                              && incomingData.status == 'running'
                              && existingData.status == 'waiting'
                              && incomingData.diff(existingData).affectedKeys().hasAll(['status', 'startTime']);

      // Rule for the first player finishing the race
      let isFirstFinisher = isSignedIn()
                            && incomingData.diff(existingData).affectedKeys().hasAll(['winnerId', 'status'])
                            && existingData.winnerId == null // IMPORTANT: only allow if no winner is set
                            && incomingData.winnerId == request.auth.uid
                            && incomingData.status == 'finished'
                            && existingData.status == 'running';
                            
      // Rule for the host forcing the race to finish
      let isHostFinishingRace = isRaceHost(raceId)
                                && incomingData.status == 'finished'
                                && existingData.status != 'finished';

      return isJoining || isHostStartingRace || isFirstFinisher || isHostFinishingRace;
    }

    //----------------------------------------------------------------//
    //                       Collection Rules                         //
    //----------------------------------------------------------------//

    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Users should not be able to list all other users
      allow create: if isCreatingValidUserProfile(userId);
      allow update: if isExistingOwner(userId) && isUpdatingValidUserProfile();
      allow delete: if isExistingOwner(userId);

      match /games/{gameId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && isCreatingValidGameEntry();
        allow update, delete: if isOwner(userId);
      }
    }

    match /leaderboard/{leaderboardEntryId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isCreatingValidLeaderboardEntry();
      allow update: if isExistingOwner(resource.data.userId) && isUpdatingValidLeaderboardEntry();
      allow delete: if isExistingOwner(resource.data.userId);
    }

    match /races/{raceId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isCreatingValidRace(raceId);
      allow update: if isUpdatingValidRace(raceId);
      allow delete: if isRaceHost(raceId);

      match /players/{userId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn();
        allow create: if isOwner(userId);
        allow update: if isOwner(userId);
        allow delete: if isOwner(userId);
      }
    }

    match /paragraphs/{paragraphId} {
      allow get: if true;
      allow list: if true;
      allow create, update, delete: if false;
    }
  }
}
